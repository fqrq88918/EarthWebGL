<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                <style>
                    body {
                        font-family: Monospace;
                        background-color: #000;
                        color: #fff;
                        margin: 0px;
                        overflow: hidden;
                    }
                #info {
                    color: #fff;
                    position: absolute;
                    top: 10px;
                    width: 100%;
                    text-align: center;
                    z-index: 100;
                    display:block;
                }
                #info a {
                    color: #046;
                    font-weight: bold;
                }
                </style>
            <title>MyFirstThreeD</title>
    </head>
    <body>
        <script src="three.min.js"></script>
        <script src="three.js"></script>
        <script src="OrbitControls.js"></script>
        <script src="TrackballControls.js"></script>
        <script src="FBXLoader.js"></script>
        <script src="inflate.min.js"></script>
        <script src="stats.min.js"></script>
        <script src="TGALoader.js"></script>
        
        <script src="DDSLoader.js"></script>
        <script src="MTLLoader.js"></script>
        <script src="OBJLoader.js"></script>
        
        <script src="EffectComposer.js"></script>
        <script src="ShaderPass.js"></script>
        <script src="OutlinePass.js"></script>
        <script src="CopyShader.js"></script>
        <script src="RenderPass.js"></script>
        <script src="FXAAShader.js"></script>
        <script src="tween.min.js"></script>
        <script src="Projector.js"></script>
        
        
        
        
       
        <script>
            var camera, controls, scene, renderer,light,stats,container;
            
            var raycaster, intersectsPlane,intersectsOther;
            var mouse, INTERSECTED,offset,SELECTED;
            
            
            var showBox;
            
            var cubeMaterial3,cubeMaterial2;
            
            var composer;
            var selectedObjects = [];
            
            var plane;
            
            var cameraEndPos;
            
            var moveCube;
            
            var timer = 0;
            var isBeginTimer;
            
            init();
            
            animate();
            
            function init()
            {
                container = document.createElement( 'div' );
                document.body.appendChild( container );
                
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xa0a0a0 );
                scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );
                
                
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.shadowMap.enabled = true;
                container.appendChild( renderer.domElement );
                
                
                document.body.appendChild( renderer.domElement );
                
                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                //camera.position.z = 10;
                controls = new THREE.TrackballControls( camera);
                //controls.target.set(0,0,0);
                camera.position.set( 0, 200, 300 );
                //camera.lookAt(scene.position);
                scene.add( camera );
                camera.updateMatrixWorld();
                /*
                controls.update();
                controls.enableDamping = false; // an animation loop is required when either damping or auto-rotation are enabled
                controls.dampingFactor = 0.25;
                controls.enablePan = false;
                controls.screenSpacePanning = false;
                controls.minDistance = 100;
               controls.maxDistance = 500;
                controls.maxPolarAngle = Math.PI / 2;
                */
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.keys = [ 65, 83, 68 ];
                controls.addEventListener( 'change', render );
                
                var geometry = new THREE.BoxGeometry( 100, 100, 100 );
                
                var material = new THREE.MeshBasicMaterial( { color: 11397866 } );
                
                /*
                moveCube = new THREE.Mesh( geometry, material );
                moveCube.position.set( 0, 200, 300 );
                moveCube.add(camera);
               // camera.position = moveCube.position;
                //controls.target = camera.position;
                scene.add( moveCube );
                */
                var ambient = new THREE.AmbientLight( 0x000000 );
				scene.add( ambient );

                light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
                light.position.set( 0, 100, 0 );
                scene.add( light );
                light = new THREE.DirectionalLight( 0xffffff );
                light.position.set( 0, 100, 0 );
                light.castShadow = true;
                light.shadow.camera.top = 180;
                light.shadow.camera.bottom = -100;
                light.shadow.camera.left = -120;
                light.shadow.camera.right = 120;
                scene.add( light );
                
                // stats
                stats = new Stats();
                container.appendChild( stats.dom );
                
                plane = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
                plane.rotation.x = - Math.PI / 2;
                plane.receiveShadow = true;
                plane.visible = true;
                scene.add( plane );
                projector = new THREE.Projector();
                //outline pass
               composer = new THREE.EffectComposer( renderer );
               var renderPass = new THREE.RenderPass( scene, camera );
               composer.addPass( renderPass );
               
               outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
               //outlinePass.renderToScreen = true;
               outlinePass.edgeStrength = 1.0;
               outlinePass.edgeGlow = 1.0;
               outlinePass.edgeThickness = 1.0;
              // outlinePass.visibleEdgeColor.setHex(0x1E0336);
               composer.addPass( outlinePass );
               
               /*
               var onLoad = function ( texture ) {
                   
                   outlinePass.patternTexture = texture;
                  texture.wrapS = THREE.RepeatWrapping;
                   texture.wrapT = THREE.RepeatWrapping;
                   
               };
               
               var loader = new THREE.TGALoader();
               
               loader.load( 'waternormals.tga', onLoad );
               */
               //var outputPass = new THREE.ShaderPass( THREE.CopyShader );
              // outputPass.renderToScreen = true;
              // composer.addPass( outputPass );
               
               
              var  effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
               effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
               effectFXAA.renderToScreen = true;
               composer.addPass( effectFXAA );
               
                var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                scene.add( grid );
                
                
//cubemap
var path = "textures/cube/SwedishRoyalCastle/";
				var format = '.jpg';
				var urls = [
						path + 'px' + format, path + 'nx' + format,
						path + 'py' + format, path + 'ny' + format,
						path + 'pz' + format, path + 'nz' + format
					];
				var reflectionCube = new THREE.CubeTextureLoader().load( urls );
				reflectionCube.format = THREE.RGBFormat;
				var refractionCube = new THREE.CubeTextureLoader().load( urls );
				refractionCube.mapping = THREE.CubeRefractionMapping;
				refractionCube.format = THREE.RGBFormat;

              //scene.background = reflectionCube;  
              var loader = new THREE.TGALoader();
                var texture1 = loader.load( '0000.tga' );
                var texture2 = loader.load( '0000_nor.tga' );
               cubeMaterial3 = new THREE.MeshStandardMaterial( { color: 0xffffff, envMap: reflectionCube, map : texture1, bumpMap : texture2 ,envMapIntensity : 1,
                roughness : 1} );
				// cubeMaterial2 = new THREE.MeshLambertMaterial( { color: 0xffee00, envMap: refractionCube, refractionRatio: 0.95 } );
				//cubeMaterial2 = new THREE.MeshLambertMaterial( { color: 0xffffff, envMap: reflectionCube } );
                
                cubeMaterial2 = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
                /*
                var loader = new THREE.TGALoader();
                var texture1 = loader.load( 'ji.tga' );
                var material1 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture1 } );
                var texture2 = loader.load( 'ji1.tga' );
                var material2 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture2 } );
                var texture3 = loader.load( 'ji2.tga' );
                var material3 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture3 } );
                
                // model
                var loader = new THREE.FBXLoader();
                loader.load( 'ji.fbx',  function(object) {
                            object.scale.x = 50;
                            object.scale.y = 50;
                            object.scale.z = 50;
                            
                            object.position.x = 400;
                           object.position.y = -200;
                           object.position.z = 0;
                            object.traverse( function ( child ) {
                                           //alert(child.name);
                                            if ( child.isMesh ) {
                                            if(child.name == "Body004")
                                            {
                                            child.material = material1;
                                            }
                                            if(child.name == "Face003")
                                            {
                                            child.material = material3;
                                            }
                                            if(child.name == "Hair_a")
                                            {
                                           child.material = material2;
                                           }
                                            
                                           
                                            child.castShadow = true;
                                            child.receiveShadow = true;
                                            
                                            }
                                            
                                            } );
                            scene.add(object);
                            });
            }
        
        */
            
            
            
            THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
           // new THREE.MTLLoader()
           // .setPath( 'models/obj/male02/' )
          //  .load( 'testbox1.mtl', function (MeshLambertMaterial) {
               // Material = cubeMaterial1;
              // MeshLambertMaterial.preload();
              var mtlLoader = new THREE.MTLLoader();
              mtlLoader.load('box3.mtl',function(material)
              {
               
              });
              var objLoader = new THREE.OBJLoader();
                 objLoader
                 //.setMaterials( material )
                 // .setPath( 'models/obj/male02/' )
                  .load( 'box3.obj', function ( object ) {
                    showBox = object.children[0];
                    showBox.material = cubeMaterial3;
                  // object.material = cubeMaterial1;
                    //alert(head.material);
                         showBox.position.x = 0;
                showBox.position.y = 0;
                        
                        scene.add( showBox );
                       //scene.add( object );
                        });
                 // } );
            
           // particles = new THREE.Points( showBox, cubeMaterial3 );
           // scene.add( particles );
            
           // raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            offset = new THREE.Vector3();
            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'mouseup', onDocumentMouseUp, false );
           // document.addEventListener( 'mouseout', onDocumentMouseOut, false );
            //document.addEventListener( 'click', onDocumentMouseClick, false );
            }
            

            //models
            /*
				var objLoader = new THREE.OBJLoader();
				//objLoader.setPath( 'models/obj/walt/' );
				objLoader.load( 'WaltHead.obj', function ( object ) {
					var head = object.children[0];
					head.scale.multiplyScalar( 15 );
					head.position.y = -500;
					head.material = cubeMaterial1;
					var head2 = head.clone();
					head2.position.x = - 900;
					head2.material = cubeMaterial2;
					var head3 = head.clone();
					head3.position.x = 900;
					head3.material = cubeMaterial3;
					scene.add( head, head2, head3 )
				} );
            }
            */
        
        /*
        function onDocumentMouseOut( event )
        {
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            
            raycaster.setFromCamera( mouse, camera );
            
            intersects = raycaster.intersectObjects( scene.children );
            
            if ( intersects.length > 0 ) {
                if ( intersects[ 0 ].object != INTERSECTED)
                {
                    INTERSECTED.material = cubeMaterial3;
                }
            }
            
            console.log("out");
        }
        */
        
        function onDocumentMouseMove( event ) {
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            
            //新建一个三维变换半单位向量 假设z方向就是0.5,这样我左右移的时候，还会有前后移的效果
          // var vector = new THREE.Vector3( mouse.x, mouse.y, 0.0);
            //屏幕和场景转换工具根据照相机，把这个向量从屏幕转化为场景中的向量
           // vector.unproject( camera );
            
          // var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
          var raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse,camera);
           intersectPlane = raycaster.intersectObject( plane);
           
           if(intersectPlane.length > 0)
           {
               //console.log(intersectPlane[0].point);
               cameraEndPos = new THREE.Vector3(intersectPlane[0].point.x,0.0,intersectPlane[0].point.z);
              
               //container.style.cursor = 'pointer';
           }
            
            
            intersectsOther = raycaster.intersectObjects( scene.children );
            if ( intersectsOther.length > 0 ) {
                
                
                
                if ( INTERSECTED != intersectsOther[ 0 ].object )
                {
                    if(INTERSECTED)
                    {
                        
                       if(INTERSECTED != plane)
                       outlinePass.selectedObjects = [];
                        
                    }
                    
                    INTERSECTED = intersectsOther[ 0 ].object;
                    //INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    if(INTERSECTED && INTERSECTED != plane)
                    {
                       //INTERSECTED.material = cubeMaterial2;
                      // outlinePass.selectedObjects = INTERSECTED;
                      
                      var selectedObject = INTERSECTED;
                      selectedObjects = [];
                      selectedObjects.push( selectedObject );
                      outlinePass.selectedObjects = selectedObjects;
                    }
                    
                       //
                }
             
            }
           
           // console.log(INTERSECTED.name);
            
        }
        
        
        function onDocumentMouseDown( event )
        {
            //console.log(showBox.position);
            event.preventDefault();
            isBeginTimer = true;
        }
        
        
        function onDocumentMouseUp( event )
        {
            //console.log(showBox.position);
           // event.preventDefault();
            cameraEndPos = new THREE.Vector3(cameraEndPos.x,200,cameraEndPos.z);
            if(timer < 10)
            {
            new TWEEN.Tween( camera.position).to( cameraEndPos, 2000 )
                                                   .start();
            }
            isBeginTimer = false;
            timer = 0;
            
          // camera.lookAt(showBox.position);
        }
       
        
        
            function animate() {
                requestAnimationFrame( animate );
                // only required if controls.enableDamping = true, or if controls.autoRotate = true
                render();
                composer.render();
                if(isBeginTimer)
                    timer ++;
                //console.log(timer);
                controls.update();
            }
        function render() {
            
           // var _box = particles.showBox;
           // var attributes = showBox.attributes;
           
          
           
            //camera.lookAt( scene.position );
            
           // console.log(intersects[0].object.name);
                
            
            
            
            renderer.render( scene, camera );
            stats.update();
            TWEEN.update();
            
        }
        
       
        
            </script>
    </body>
</html>
